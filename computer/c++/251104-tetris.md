README â€” Tetris in C++ (single-file) for Ubuntu + VSCode
-------------------------------------------------------
This file contains:
  1) A step-by-step setup & run guide (this comment block).
  2) A complete single-file C++ Tetris implementation using ncurses.

Open this file in VSCode and follow the steps below.

1) Install required packages on Ubuntu
-------------------------------------
Open a terminal and run:

  sudo apt update
  sudo apt install -y build-essential g++ cmake libncurses5-dev libncursesw5-dev

2) Save this file
-----------------
Save this file as `tetris.cpp` in an empty folder (project folder).

3) Compile from terminal
------------------------
Compile with:

  g++ -std=c++17 tetris.cpp -lncurses -o tetris

If you prefer clang++:

  clang++ -std=c++17 tetris.cpp -lncurses -o tetris

4) Run
------
From the project folder run:

  ./tetris

Controls (in-game):
  - Left arrow : move left
  - Right arrow: move right
  - Down arrow : soft drop (speed up)
  - Up arrow   : rotate clockwise
  - Space      : hard drop
  - p or P     : pause
  - q or Q     : quit

5) VSCode configuration (optional)
----------------------------------
To be able to build and run from VSCode's Run/Debug and Tasks, add these files under the `.vscode/` folder.

.vscode/tasks.json (build task):
```
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "build tetris",
      "type": "shell",
      "command": "g++",
      "args": ["-std=c++17", "tetris.cpp", "-lncurses", "-o", "tetris"],
      "group": { "kind": "build", "isDefault": true },
      "problemMatcher": ["$gcc"]
    }
  ]
}
```
.vscode/launch.json (run/debug configuration):
```
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Run Tetris",
      "type": "cppdbg",
      "request": "launch",
      "program": "${workspaceFolder}/tetris",
      "args": [],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": true,
      "MIMode": "gdb"
    }
  ]
}
```
Notes:
 - `externalConsole: true` ensures ncurses can control the terminal while debugging.
 - If you use the built-in terminal for debugging, some terminals may conflict with ncurses.

6) Troubleshooting
------------------
- If `-lncurses` link fails, ensure libncurses5-dev is installed.
- If key inputs aren't responsive, run the binary in a real terminal (not the VSCode debug console).
- For Windows users: this file targets Linux/Ubuntu; use WSL for best compatibility.

Now scroll down to the implementation below.

```cc
#include <ncurses.h>
#include <vector>
#include <array>
#include <chrono>
#include <thread>
#include <random>
#include <algorithm>
#include <string>

using namespace std::chrono_literals;

// Game constants
constexpr int BOARD_W = 10;
constexpr int BOARD_H = 20;
constexpr int PREVIEW_W = 6;

// Tetromino definitions (4x4 grids encoded as 16-bit masks)
// Seven classic pieces: I O T S Z J L
const std::array<std::array<int,4>,7> TETROMINO = {
    std::array<int,4>{0x0F00, 0x2222, 0x00F0, 0x4444}, // I
    std::array<int,4>{0x6600, 0x6600, 0x6600, 0x6600}, // O
    std::array<int,4>{0x0E40, 0x4C40, 0x4E00, 0x4640}, // T
    std::array<int,4>{0x06C0, 0x8C40, 0x06C0, 0x8C40}, // S (note: consistent rotations)
    std::array<int,4>{0x0C60, 0x4C80, 0x0C60, 0x4C80}, // Z
    std::array<int,4>{0x08E0, 0x6440, 0x0E20, 0x44C0}, // J
    std::array<int,4>{0x02E0, 0x4460, 0x0E80, 0xC440}  // L
};

struct Piece {
    int type;   // 0..6
    int rot;    // 0..3
    int x, y;   // position of top-left of 4x4 box on board
};

struct Game {
    std::vector<int> board; // BOARD_W * BOARD_H, 0 empty, >0 filled with color index
    Piece cur;
    Piece next;
    std::mt19937 rng;
    int score = 0;
    int level = 1;
    int lines = 0;
    bool gameover = false;
    bool paused = false;

    Game(): board(BOARD_W*BOARD_H, 0), rng(std::random_device{}()) {
        spawn_next();
        spawn_cur();
    }

    void spawn_next() {
        std::uniform_int_distribution<int> d(0,6);
        next.type = d(rng);
        next.rot = 0;
        next.x = BOARD_W/2 - 2;
        next.y = 0;
    }

    void spawn_cur() {
        cur = next;
        cur.x = BOARD_W/2 - 2;
        cur.y = 0;
        spawn_next();
        if (!is_valid(cur)) gameover = true;
    }

    int cell_mask(int type, int rot, int i, int j) const {
        // i: row 0..3, j: col 0..3
        int mask = TETROMINO[type][rot & 3];
        int bit = 1 << (15 - (i*4 + j));
        return (mask & bit) ? 1 : 0;
    }

    bool is_valid(const Piece &p) const {
        for (int i=0;i<4;i++) for (int j=0;j<4;j++) {
            if (!cell_mask(p.type, p.rot, i,j)) continue;
            int bx = p.x + j;
            int by = p.y + i;
            if (bx < 0 || bx >= BOARD_W || by < 0 || by >= BOARD_H) return false;
            if (board[by*BOARD_W + bx]) return false;
        }
        return true;
    }

    void lock_piece() {
        for (int i=0;i<4;i++) for (int j=0;j<4;j++) {
            if (!cell_mask(cur.type, cur.rot, i,j)) continue;
            int bx = cur.x + j;
            int by = cur.y + i;
            if (by >= 0 && by < BOARD_H && bx >=0 && bx < BOARD_W)
                board[by*BOARD_W + bx] = cur.type + 1;
        }
        clear_lines();
        spawn_cur();
    }

    void clear_lines() {
        int cleared = 0;
        for (int r=BOARD_H-1;r>=0;r--) {
            bool full = true;
            for (int c=0;c<BOARD_W;c++) if (!board[r*BOARD_W + c]) { full = false; break; }
            if (full) {
                cleared++;
                // move everything above down
                for (int rr=r; rr>0; rr--) for (int c=0;c<BOARD_W;c++) board[rr*BOARD_W + c] = board[(rr-1)*BOARD_W + c];
                for (int c=0;c<BOARD_W;c++) board[c] = 0;
                r++; // re-check this row
            }
        }
        if (cleared) {
            lines += cleared;
            score += (cleared==1?100:cleared==2?300:cleared==3?500:800) * level;
            level = 1 + lines/10;
        }
    }

    void rotate_cur() {
        Piece p = cur;
        p.rot = (p.rot+1)&3;
        // simple wall-kick attempts
        const int kicks[] = {0, -1, 1, -2, 2};
        for (int k : kicks) {
            p.x = cur.x + k;
            if (is_valid(p)) { cur = p; return; }
        }
    }

    void move_cur(int dx, int dy) {
        Piece p = cur;
        p.x += dx; p.y += dy;
        if (is_valid(p)) cur = p;
        else if (dy>0) { // collision when moving down
            lock_piece();
        }
    }

    void hard_drop() {
        while (true) {
            Piece p = cur; p.y++;
            if (is_valid(p)) cur = p; else { lock_piece(); break; }
        }
    }
};

// Drawing helpers
void draw_board(WINDOW* win, const Game &g) {
    werase(win);
    box(win, 0, 0);
    for (int r=0;r<BOARD_H;r++) for (int c=0;c<BOARD_W;c++) {
        int val = g.board[r*BOARD_W + c];
        if (val) mvwaddch(win, 1+r, 1+c*2, ' ' | A_REVERSE), mvwaddch(win, 1+r, 1+c*2+1, ' ' | A_REVERSE);
        else mvwaddch(win, 1+r, 1+c*2, '.'), mvwaddch(win, 1+r, 1+c*2+1, '.');
    }
    // draw current piece
    for (int i=0;i<4;i++) for (int j=0;j<4;j++) if (g.cell_mask(g.cur.type, g.cur.rot, i,j)) {
        int bx = g.cur.x + j;
        int by = g.cur.y + i;
        if (by >= 0 && by < BOARD_H && bx >= 0 && bx < BOARD_W) {
            mvwaddch(win, 1+by, 1+bx*2, ' ' | A_REVERSE);
            mvwaddch(win, 1+by, 1+bx*2+1, ' ' | A_REVERSE);
        }
    }
    wrefresh(win);
}

void draw_info(WINDOW* win, const Game &g) {
    werase(win);
    box(win,0,0);
    mvwprintw(win,1,1,"Score: %d", g.score);
    mvwprintw(win,2,1,"Lines: %d", g.lines);
    mvwprintw(win,3,1,"Level: %d", g.level);
    mvwprintw(win,5,1,"Next:");
    // draw next piece in a 4x4 area
    for (int i=0;i<4;i++) for (int j=0;j<4;j++) {
        if (g.cell_mask(g.next.type, g.next.rot, i,j)) mvwaddch(win, 7+i, 1+j*2, ' ' | A_REVERSE), mvwaddch(win,7+i,1+j*2+1,' ' | A_REVERSE);
        else mvwaddch(win, 7+i, 1+j*2, ' '), mvwaddch(win,7+i,1+j*2+1,' ');
    }
    mvwprintw(win, 13,1, "Controls:");
    mvwprintw(win, 14,1, "Arrows: move/rotate");
    mvwprintw(win, 15,1, "Space: hard drop");
    mvwprintw(win, 16,1, "p: pause, q: quit");
    if (g.paused) mvwprintw(win, 18,1, "-- PAUSED --");
    if (g.gameover) mvwprintw(win, 19,1, "-- GAME OVER --");
    wrefresh(win);
}

int main() {
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, TRUE);
    nodelay(stdscr, TRUE);
    curs_set(0);

    // calculate window sizes
    int board_win_w = 1 + BOARD_W*2 + 1; // borders and 2 chars per column
    int board_win_h = 1 + BOARD_H + 1;
    int info_win_w = 20;
    int info_win_h = board_win_h;

    WINDOW* board_win = newwin(board_win_h, board_win_w, 0, 0);
    WINDOW* info_win = newwin(info_win_h, info_win_w, 0, board_win_w + 1);

    Game game;

    auto last_tick = std::chrono::steady_clock::now();
    double tick_interval = 0.8; // seconds; will be reduced by level

    bool running = true;
    while (running) {
        // timing
        tick_interval = std::max(0.05, 0.8 - (game.level-1) * 0.05);
        auto now = std::chrono::steady_clock::now();
        double elapsed = std::chrono::duration<double>(now - last_tick).count();
        if (!game.paused && !game.gameover && elapsed >= tick_interval) {
            game.move_cur(0,1);
            last_tick = now;
        }

        // input
        int ch = getch();
        switch (ch) {
            case KEY_LEFT: game.move_cur(-1,0); break;
            case KEY_RIGHT: game.move_cur(1,0); break;
            case KEY_DOWN: game.move_cur(0,1); break;
            case KEY_UP: game.rotate_cur(); break;
            case ' ': game.hard_drop(); break;
            case 'p': case 'P': game.paused = !game.paused; break;
            case 'q': case 'Q': running = false; break;
            case ERR: break; // no input
            default: break;
        }

        draw_board(board_win, game);
        draw_info(info_win, game);

        std::this_thread::sleep_for(10ms);
    }

    // cleanup
    delwin(board_win);
    delwin(info_win);
    endwin();

    return 0;
}
```

7) Want improvements?
----------------------
I can:
 - Split the code into multiple files (header + source).
 - Add a Makefile or CMakeLists.txt.
 - Add hold piece, next-piece preview, levels, sound, or higher-quality rendering.
