# Scala Caprese project - Capabilities and Resources for Effects

The Scala Caprese project, short for Capabilities and Resources for Effects, is a major research initiative led by Scala's creator, Martin Odersky, at EPFL. The project's goal is to introduce first-class language support for managing and tracking side effects and resource usage at the type level. 
This project builds upon existing work in Scala 3, including: 
- Context functions: For abstracting over capability passing.
- Capture checking: To enforce which capabilities a lambda or object can close over. 

## Core capabilities
- __Type-level effect tracking__: Caprese aims to extend Scala's type system to statically track side effects and resource access. This allows the compiler to guarantee at compile-time that certain operations, like accessing a file, are only performed with the proper permissions, known as "capabilities".
- **Sound resource management**: Using capabilities, the system can prevent resource leaks by ensuring that resources are not allowed to "escape" their designated scope. The type system can guarantee, for example, that a file is properly closed after it is used within a certain block of code.
- **Direct-style effect handling**: The project explores providing a more "direct-style" or imperative way of writing effectful code, similar to Rust, without requiring complex monadic wrapping like Future or IO. This could improve ergonomics and potentially bridge the gap for developers less familiar with pure functional programming patterns.
- __Enhanced safety for low-level code__: By applying static guarantees about mutability and resource access, Caprese is designed to make low-level imperative code safer without needing a runtime interpreter.
- __Algebraic effect system primitives__: The research involves developing primitives for a compositional capabilities ecosystem that could also improve existing libraries like Cats Effect. 

## Goals and motivations
The Caprese project seeks to solve long-standing challenges in programming language design, specifically: 
- __Ecosystem fragmentation__: By providing a standard, language-level way to handle effects and resources, Caprese could reduce the need for multiple, competing effect systems in the Scala ecosystem.
- __Improved safety and productivity__: The project's innovations are intended to foster safer and more productive programming by catching errors at compile time instead of runtime.
- __Reduced complexity__: Some approaches, like "direct-style" effects, are meant to be easier for engineers to adopt and debug.

## Status and outlook
Caprese is a long-term research project funded by the Swiss National Fund. 
It is a high-level research effort rather than a specific feature scheduled for an immediate Scala release. 
While some early concepts like context functions and capture checking are already part of Scala 3, the full vision of Caprese 
is a significant, multi-year undertaking. 

The ultimate impact of the project is a subject of active discussion in the Scala community. 
Some believe it could dramatically change the language and its libraries, while others are cautiously 
awaiting more concrete examples and documentation. Some critics express concern about the project's potential 
to introduce breaking changes and add complexity, similar to the transition from Scala 2 to Scala 3. 
However, supporters and Odersky's team believe the direction makes a lot of sense for building safer and more performant solutions in the future. 

# Code Sample

As of late 2025, the features for capabilities and resources remain experimental in Scala, but the foundational concepts, especially "capture checking," are available behind a language flag in recent Scala 3 releases.

This example demonstrates how capture checking prevents a resource leak by ensuring a file's capability cannot "escape" the scope where it is safely managed.

### 1. Enabling the feature
To run this code, you must first enable the experimental feature in your build.sbt:
```
// build.sbt
scalacOptions += "-language:experimental.captureChecking"
```

### 2. Experimental file handling code
This code snippet showcases how the compiler catches a common resource-handling bug:
```scala
import scala.caps.Capability
import java.io.FileOutputStream

// The `usingLogFile` method takes a block of code (an operation) that
// operates on a newly created FileOutputStream resource.
// The `op` function's type is `FileOutputStream^{logFile} => T`.
// This capture-checked type ensures that `op` can only use `logFile`
// within its own scope, not capture it to be used later.
def usingLogFile[T](op: FileOutputStream^{logFile} => T): T = {
  val logFile = new FileOutputStream("log.txt")
  try {
    op(logFile)
  } finally {
    logFile.close()
  }
}

// A function that attempts to escape the resource's scope.
// Because it captures the `file` capability in a lambda `() => ...`,
// the compiler will issue a compile-time error.
def unsoundOperation() = {
  // `usingLogFile` creates the resource, and the function `file => () => ...`
  // attempts to capture it. This is rejected by the capture checker.
  val later = usingLogFile { file =>
    () => file.write(42) // COMPILE ERROR: Cannot capture the 'file' capability
  }
  
  // If the compiler allowed this, calling `later()` here would crash because
  // the `logFile` was already closed.
  // later()
}

// A sound operation that uses the resource safely within the provided scope.
// This code compiles successfully.
def soundOperation() = {
  usingLogFile { file =>
    file.write(100)
    println("Successfully wrote to file")
  }
}
```

## Explanation of the experimental features
- __import scala.caps.Capability:__ This import is part of the experimental feature set. Capability is the base trait for any value that should be tracked by the capture checker. The logFile resource is treated as a capability.
- __FileOutputStream^{logFile}:__ This is the core syntax of capture checking. It defines a "capturing type."
  - The ^ operator indicates that this type carries a "capture set."
  - The {logFile} is the capture set, indicating that any function with this type is allowed to capture a reference to the specific logFile capability.
- __Preventing escape:__ In unsoundOperation, the anonymous function () => file.write(42) is an object that closes over the file capability. Since the type of later would need to contain the logFile capability in its capture set, the compiler prevents this assignment. It recognizes that file will be closed by usingLogFile and that the later function would be attempting to use a stale resource.
- __Allowing safe usage:__ In soundOperation, the lambda is used and discarded within the dynamic extent of the usingLogFile call. The compiler recognizes that no capability reference escapes this controlled scope, so the code is safe and passes the capture check.
